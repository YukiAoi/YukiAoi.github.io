<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.36">
    <style>
      :root {
        --c-bg: #fff;
      }
      html.dark {
        --c-bg: #22272e;
      }
      html, body {
        background-color: var(--c-bg);
      }
    </style>
    <script>
      const userMode = localStorage.getItem('vuepress-color-scheme');
			const systemDarkMode = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
			if (userMode === 'dark' || (userMode !== 'light' && systemDarkMode)) {
				document.documentElement.classList.toggle('dark', true);
			}
    </script>
    <link rel="icon" href="/images/logo.jpg"><title>YukiAoi's front end notes</title><meta name="description" content="前端学习笔记">
    <link rel="modulepreload" href="/assets/app.ebe36e73.js"><link rel="modulepreload" href="/assets/computerNet.html.1d8b61ad.js"><link rel="modulepreload" href="/assets/computerNet.html.0fb41bfb.js">
    <link rel="stylesheet" href="/assets/style.8f96e109.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container"><!--[--><header ref_key="navbar" class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><img class="logo" src="/images/logo.jpg" alt="YukiAoi&#39;s front end notes"><span class="site-name can-hide">YukiAoi&#39;s front end notes</span></a></span><div class="navbar-items-wrapper" style=""><!--[--><!--]--><nav class="navbar-items can-hide"><!--[--><div class="navbar-item"><a href="/weber/htmlAndCss.md" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/other/computerNet.md" class="" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><form class="search-box" role="search"><input type="search" placeholder="搜索" autocomplete="off" spellcheck="false" value><!----></form></div></header><!--]--><div class="sidebar-mask"></div><!--[--><aside class="sidebar"><nav class="navbar-items"><!--[--><div class="navbar-item"><a href="/weber/htmlAndCss.md" class="" aria-label="前端"><!--[--><!--]--> 前端 <!--[--><!--]--></a></div><div class="navbar-item"><a href="/other/computerNet.md" class="" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-items"><!--[--><li><p tabindex="0" class="sidebar-item sidebar-heading">前端 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/weber/html5.md" class="sidebar-item" aria-label="HTML"><!--[--><!--]--> HTML <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item collapsible">CSS <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/weber/css/selector.md" class="sidebar-item" aria-label="选择器"><!--[--><!--]--> 选择器 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/increaseAndDowngrade.md" class="sidebar-item" aria-label="渐进增强与优雅降级"><!--[--><!--]--> 渐进增强与优雅降级 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/compatibility.md" class="sidebar-item" aria-label="兼容性"><!--[--><!--]--> 兼容性 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/newProperty.md" class="sidebar-item" aria-label="CSS3新特性"><!--[--><!--]--> CSS3新特性 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/propertyPosition.md" class="sidebar-item" aria-label="position属性"><!--[--><!--]--> position属性 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/boxModel.md" class="sidebar-item" aria-label="盒模型"><!--[--><!--]--> 盒模型 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/bfc.md" class="sidebar-item" aria-label="块级格式化上下文(BFC)"><!--[--><!--]--> 块级格式化上下文(BFC) <!--[--><!--]--></a><!----></li><li><a href="/weber/css/layout.md" class="sidebar-item" aria-label="页面布局"><!--[--><!--]--> 页面布局 <!--[--><!--]--></a><!----></li><li><a href="/weber/css/preprocessor.md" class="sidebar-item" aria-label="预处理器（Sass，Less，Stylus）"><!--[--><!--]--> 预处理器（Sass，Less，Stylus） <!--[--><!--]--></a><!----></li><li><a href="/weber/css/commonProblem.md" class="sidebar-item" aria-label="常见问题"><!--[--><!--]--> 常见问题 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item collapsible">JavaScript <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/weber/js/dataType.md" class="sidebar-item" aria-label="数据类型"><!--[--><!--]--> 数据类型 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/declare.md" class="sidebar-item" aria-label="变量声明"><!--[--><!--]--> 变量声明 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/scope.md" class="sidebar-item" aria-label="作用域"><!--[--><!--]--> 作用域 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/closure.md" class="sidebar-item" aria-label="闭包"><!--[--><!--]--> 闭包 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/this.md" class="sidebar-item" aria-label="this"><!--[--><!--]--> this <!--[--><!--]--></a><!----></li><li><a href="/weber/js/prototype.md" class="sidebar-item" aria-label="原型和原型链"><!--[--><!--]--> 原型和原型链 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/eventLoop.md" class="sidebar-item" aria-label="事件循环（eventLoop）"><!--[--><!--]--> 事件循环（eventLoop） <!--[--><!--]--></a><!----></li><li><a href="/weber/js/debouncedAndThrottling.md" class="sidebar-item" aria-label="防抖节流"><!--[--><!--]--> 防抖节流 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/copy.md" class="sidebar-item" aria-label="深浅拷贝"><!--[--><!--]--> 深浅拷贝 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/arrayFunction.md" class="sidebar-item" aria-label="数组方法"><!--[--><!--]--> 数组方法 <!--[--><!--]--></a><!----></li><li><a href="/weber/js/promise.md" class="sidebar-item" aria-label="promise"><!--[--><!--]--> promise <!--[--><!--]--></a><!----></li><li><a href="/weber/js/es6plus.md" class="sidebar-item" aria-label="es6+"><!--[--><!--]--> es6+ <!--[--><!--]--></a><!----></li><li><a href="/weber/js/currying.md" class="sidebar-item" aria-label="函数柯里化"><!--[--><!--]--> 函数柯里化 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/weber/typeScript.md" class="sidebar-item" aria-label="TypeScript"><!--[--><!--]--> TypeScript <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item collapsible">Vue <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/weber/vue/mvvm.md" class="sidebar-item" aria-label="视图模型双向绑定"><!--[--><!--]--> 视图模型双向绑定 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/lifeCycle.md" class="sidebar-item" aria-label="生命周期"><!--[--><!--]--> 生命周期 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/computedAndWatch.md" class="sidebar-item" aria-label="计算属性与属性监听"><!--[--><!--]--> 计算属性与属性监听 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/diff.md" class="sidebar-item" aria-label="diff算法"><!--[--><!--]--> diff算法 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/communication.md" class="sidebar-item" aria-label="组件通信"><!--[--><!--]--> 组件通信 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/nextTick.md" class="sidebar-item" aria-label="nextTick"><!--[--><!--]--> nextTick <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/slot.md" class="sidebar-item" aria-label="插槽"><!--[--><!--]--> 插槽 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/keepAlive.md" class="sidebar-item" aria-label="keep-alive"><!--[--><!--]--> keep-alive <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/mixin.md" class="sidebar-item" aria-label="混合"><!--[--><!--]--> 混合 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/router.md" class="sidebar-item" aria-label="路由"><!--[--><!--]--> 路由 <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/vuex.md" class="sidebar-item" aria-label="vuex"><!--[--><!--]--> vuex <!--[--><!--]--></a><!----></li><li><a href="/weber/vue/other.md" class="sidebar-item" aria-label="其他"><!--[--><!--]--> 其他 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/weber/react.md" class="sidebar-item" aria-label="React"><!--[--><!--]--> React <!--[--><!--]--></a><!----></li><li><a href="/weber/electron.md" class="sidebar-item" aria-label="Electron"><!--[--><!--]--> Electron <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><p tabindex="0" class="sidebar-item sidebar-heading active">其他 <!----></p><!--[--><ul style="" class="sidebar-item-children"><!--[--><li><a href="/other/computerNet.md" class="sidebar-item active" aria-label="计算机网络"><!--[--><!--]--> 计算机网络 <!--[--><!--]--></a><!----></li><li><a href="/other/browser.md" class="sidebar-item" aria-label="浏览器"><!--[--><!--]--> 浏览器 <!--[--><!--]--></a><!----></li><li><a href="/other/git.md" class="sidebar-item" aria-label="Git"><!--[--><!--]--> Git <!--[--><!--]--></a><!----></li><li><p tabindex="0" class="sidebar-item collapsible">Webpack <span class="right arrow"></span></p><!--[--><ul style="display:none;" class="sidebar-item-children"><!--[--><li><a href="/other/webpack/start.md" class="sidebar-item" aria-label="入门"><!--[--><!--]--> 入门 <!--[--><!--]--></a><!----></li><li><a href="/other/webpack/vueEnvironment.md" class="sidebar-item" aria-label="搭建vue开发环境"><!--[--><!--]--> 搭建vue开发环境 <!--[--><!--]--></a><!----></li><li><a href="/other/webpack/doitself.md" class="sidebar-item" aria-label="手写webpack"><!--[--><!--]--> 手写webpack <!--[--><!--]--></a><!----></li><li><a href="/other/webpack/optimization.md" class="sidebar-item" aria-label="优化"><!--[--><!--]--> 优化 <!--[--><!--]--></a><!----></li><li><a href="/other/webpack/strategy.md" class="sidebar-item" aria-label="打包策略"><!--[--><!--]--> 打包策略 <!--[--><!--]--></a><!----></li><li><a href="/other/webpack/principle.md" class="sidebar-item" aria-label="webpack原理"><!--[--><!--]--> webpack原理 <!--[--><!--]--></a><!----></li><li><a href="/other/webpack/pluginAndLoader.md" class="sidebar-item" aria-label="Plugin和Loader的区别"><!--[--><!--]--> Plugin和Loader的区别 <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><li><a href="/other/babel.md" class="sidebar-item" aria-label="Babel"><!--[--><!--]--> Babel <!--[--><!--]--></a><!----></li><li><a href="/other/node.md" class="sidebar-item" aria-label="Node"><!--[--><!--]--> Node <!--[--><!--]--></a><!----></li><!--]--></ul><!--]--></li><!--]--></ul><!--[--><!--]--></aside><!--]--><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h2 id="计算机网络" tabindex="-1"><a class="header-anchor" href="#计算机网络" aria-hidden="true">#</a> 计算机网络</h2><h3 id="http的基本概念" tabindex="-1"><a class="header-anchor" href="#http的基本概念" aria-hidden="true">#</a> HTTP的基本概念</h3><p>http: 是互联网上应用最为广泛的一种网络协议，是一个客户端和服务器端<code>请求和应答的标准（TCP）</code>，用于从 WWW 服务器传输超文本到本地浏览器的<code>超文本传输协议</code>。</p><h3 id="http工作原理" tabindex="-1"><a class="header-anchor" href="#http工作原理" aria-hidden="true">#</a> HTTP工作原理</h3><p>HTTP协议定义Web客户端如何从Web服务器请求Web页面，以及服务器如何把Web页面传送给客户端。客户端向服务器发送一个请求报文，服务器以一个状态行作为响应。</p><h3 id="http请求-响应的步骤" tabindex="-1"><a class="header-anchor" href="#http请求-响应的步骤" aria-hidden="true">#</a> HTTP请求/响应的步骤</h3><ol><li>客户端连接到Web服务器</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP响应</li><li>释放TCP连接</li><li>客户端（浏览器）解析HTML内容</li></ol><h3 id="http-的-5-种方法" tabindex="-1"><a class="header-anchor" href="#http-的-5-种方法" aria-hidden="true">#</a> HTTP 的 5 种方法</h3><ol><li>GET---获取资源</li><li>POST---传输资源</li><li>PUT---更新资源</li><li>DELETE---删除资源</li><li>HEAD---获取报文首部</li></ol><h3 id="get与post的区别" tabindex="-1"><a class="header-anchor" href="#get与post的区别" aria-hidden="true">#</a> GET与POST的区别</h3><ol><li>get只读，post可以修改</li><li>get的参数放在url中，post的放在请求体中</li><li>post回退时会重新请求</li><li>浏览器会主动缓存get请求地址</li><li>get的请求参数会被保留在浏览器历史记录中</li><li>get的参数有长度限制（受url长度限制，每个浏览器的长度都不一样）</li></ol><h3 id="http报文的组成成分" tabindex="-1"><a class="header-anchor" href="#http报文的组成成分" aria-hidden="true">#</a> HTTP报文的组成成分</h3><ol><li>请求报文：</li></ol><ul><li>请求行</li><li>请求头</li><li>空行</li><li>请求体</li></ul><ol start="2"><li>请求行：</li></ol><ul><li>http方法</li><li>页面地址</li><li>http协议</li><li>http版本</li></ul><ol start="3"><li>响应报文：</li></ol><ul><li>状态行</li><li>响应头</li><li>空行</li><li>响应体</li></ul><p><strong>Request Header:</strong></p><ol><li><code>GET /sample.Jsp HTTP/1.1</code>请求行</li><li><strong>Host:</strong> <code>www.uuid.online</code>求的目标域名和端口号</li><li><strong>Origin:</strong> <code>http://localhost:8081/</code>请求的来源域名和端口号 （跨域请求时，浏览器会自动带上这个头信息）</li><li><strong>Referer:</strong> <code>https://localhost:8081/link?query=xxxxx</code>请求资源的完整URI</li><li><strong>User-Agent:</strong> <code>Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/67.0.3396.99 Safari/537.36</code>浏览器信息</li><li><strong>Cookie:</strong> <code>BAIDUID=FA89F036:FG=1; BD_HOME=1; sugstore=0</code>当前域名下的Cookie</li><li><strong>Accept:</strong> <code>text/html,image/png</code>代表客户端希望接受的数据类型是html或者是png图片类型</li><li><strong>Accept-Encoding:</strong> <code>gzip, deflate</code>代表客户端能支持gzip和deflate格式的压缩</li><li><strong>Accept-Language:</strong> <code>zh-CN,zh;q=0.9</code>代表客户端可以支持语言zh-CN或者zh(值得一提的是q(0~1)是优先级权重的意思，不写默认为1，这里zh-CN是1，zh是0.9)</li><li><strong>Connection:</strong> <code>keep-alive</code>告诉服务器，客户端需要的tcp连接是一个长连接</li></ol><p><strong>Response Header:</strong></p><ol><li><code>HTTP/1.1 200 OK</code>响应状态行</li><li><strong>Date:</strong> <code>Mon, 30 Jul 2018 02:50:55 GMT</code>服务端发送资源时的服务器时间</li><li><strong>Expires:</strong> <code>Wed, 31 Dec 1969 23:59:59 GMT</code>比较过时的一种验证缓存的方式，与浏览器（客户端）的时间比较，超过这个时间就不用缓存（不和服务器进行验证），适合版本比较稳定的网页</li><li><strong>Cache-Control:</strong> <code>no-cache</code>现在最多使用的控制缓存的方式，会和服务器进行缓存验证</li><li><strong>etag:</strong> <code>fb8ba2f80b1d324bb997cbe188f28187-ssl-df</code>一般是<a href="http://www.t086.com/article/5207" target="_blank" rel="noopener noreferrer">Nginx静态服务器<span><svg class="external-link-icon" xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><span class="external-link-icon-sr-only">open in new window</span></span></a>发来的静态文件签名，浏览在没有“Disabled cache”情况下，接收到etag后，同一个url第二次请求就会自动带上“If-None-Match”</li><li><strong>Last-Modified:</strong> <code>Fri, 27 Jul 2018 11:04:55 GMT</code>是服务器发来的当前资源最后一次修改的时间，下次请求时，如果服务器上当前资源的修改时间大于这个时间，就返回新的资源内容</li><li><strong>Content-Type:</strong> <code>text/html; charset=utf-8</code>如果返回是流式的数据，我们就必须告诉浏览器这个头，不然浏览器会下载这个页面，同时告诉浏览器是utf8编码，否则可能出现乱码</li><li><strong>Content-Encoding:</strong> <code>gzip</code>告诉客户端，应该采用gzip对资源进行解码</li><li><strong>Connection:</strong> <code>keep-alive</code>告诉客户端服务器的tcp连接也是一个长连接</li></ol><h3 id="https-的基本概念" tabindex="-1"><a class="header-anchor" href="#https-的基本概念" aria-hidden="true">#</a> https 的基本概念</h3><p>https:是以安全为目标的 HTTP 通道，即HTTP下加入SSL层进行加密。</p><p>https协议的作用：建立一个信息安全通道，来确保数据的传输，确保网站的真实性。</p><h3 id="http-和-https-的区别" tabindex="-1"><a class="header-anchor" href="#http-和-https-的区别" aria-hidden="true">#</a> http 和 https 的区别？</h3><ol><li>http是明文，https有ssl加密</li><li>https需要证书</li><li>端口不通</li><li>链接方式不同，http是无状态的</li></ol><h4 id="https-协议的工作原理" tabindex="-1"><a class="header-anchor" href="#https-协议的工作原理" aria-hidden="true">#</a> https 协议的工作原理</h4><p>客户端在使用 HTTPS 方式与 Web 服务器通信时有以下几个步骤：</p><ol><li>客户端使用 https url 访问服务器，则要求 web 服务器<code>建立 ssl 链接</code>。</li><li>web 服务器接收到客户端的请求之后，会<code>将网站的证书（证书中包含了公钥），传输给客户端</code>。</li><li>客户端和 web 服务器端开始<code>协商 SSL 链接的安全等级</code>，也就是加密等级。</li><li>客户端浏览器通过双方协商一致的安全等级，<code>建立会话密钥</code>，然后通过网站的公钥来加密会话密钥，并传送给网站。</li><li>web 服务器<code>通过自己的私钥解密出会话密钥</code>。</li><li>web 服务器<code>通过会话密钥加密与客户端之间的通信</code>。</li></ol><h4 id="https-协议的优缺点" tabindex="-1"><a class="header-anchor" href="#https-协议的优缺点" aria-hidden="true">#</a> https 协议的优缺点</h4><ol><li>HTTPS 协议要比 http 协议<code>安全</code>，可防止数据在传输过程中被窃取、改变，确保数据的完整性。</li><li>https 握手阶段比较<code>费时</code>，会使页面加载时间延长 50%，增加 10%~20%的耗电。</li><li>https <code>缓存</code>不如 http 高效，会增加数据开销。</li><li>SSL 证书也需要钱，功能越强大的<code>证书费</code>用越高。</li><li>SSL 证书需要绑定 <code>IP</code>，不能再同一个 ip 上绑定多个域名，ipv4 资源支持不了这种消耗。</li></ol><h3 id="tcp-ip网络模型" tabindex="-1"><a class="header-anchor" href="#tcp-ip网络模型" aria-hidden="true">#</a> TCP/IP网络模型</h3><p>TCP/IP模型是互联网的基础，它是一系列网络协议的总称。这些协议可以划分为四层，分别为链路层、网络层、传输层和应用层。</p><ol><li>链路层：负责封装和解封装IP报文，发送和接受ARP/RARP报文等。</li><li>网络层：负责路由以及把分组报文发送给目标网络或主机。</li><li>传输层：负责对报文进行分组和重组，并以TCP或UDP协议格式封装报文。</li><li>应用层：负责向用户提供应用程序，比如HTTP、FTP、Telnet、DNS、SMTP等。</li></ol><h3 id="tcp三次握手" tabindex="-1"><a class="header-anchor" href="#tcp三次握手" aria-hidden="true">#</a> TCP三次握手</h3><ol><li>第一次握手：<code>建立连接时，客户端发送syn包（syn=j）到服务器，并进入SYN_SENT状态，等待服务器确认</code>；SYN：同步序列编号（Synchronize Sequence Numbers）。</li><li>第二次握手：<code>服务器收到syn包并确认客户的SYN</code>（ack=j+1），<code>同时也发送一个自己的SYN包</code>（syn=k），即SYN+ACK包，此时服务器进入SYN_RECV状态；</li><li>第三次握手：<code>客户端收到服务器的SYN+ACK包，向服务器发送确认包ACK(ack=k+1）</code>，此包发送完毕，客户端和服务器进入ESTABLISHED（TCP连接成功）状态，完成三次握手。</li></ol><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>握手过程中传送的包里不包含数据，三次握手完毕后，客户端与服务器才正式开始传送数据。
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br></div></div><h3 id="tcp-四次挥手" tabindex="-1"><a class="header-anchor" href="#tcp-四次挥手" aria-hidden="true">#</a> TCP 四次挥手</h3><ol><li><code>客户端进程发出连接释放报文</code>，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为seq=u（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li><li><code>服务器收到连接释放报文，发出确认报文</code>，ACK=1，ack=u+1，并且带上自己的序列号seq=v，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li><li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最 后的数据）。</li><li><code>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文</code>，FIN=1，ack=u+1，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为seq=w，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li><li><code>客户端收到服务器的连接释放报文后，必须发出确认</code>，ACK=1，ack=w+1，而自己的序列号是seq=u+1，此时，客户端就进入了TIME-WAIT（时间等待）状态。注意此时TCP连接还没有释放，必须经过2∗∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态。</li><li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li></ol><h3 id="tcp和udp的区别" tabindex="-1"><a class="header-anchor" href="#tcp和udp的区别" aria-hidden="true">#</a> TCP和UDP的区别</h3><ol><li>TCP是面向<code>连接</code>的，而UDP是面向无连接的。</li><li>TCP仅支持<code>单播传输</code>，UDP 提供了单播，多播，广播的功能。</li><li>TCP的三次握手保证了连接的<code>可靠性</code>; UDP是无连接的、不可靠的一种数据传输协议，首先不可靠性体现在无连接上，通信都不需要建立连接，对接收到的数据也不发送确认信号，发送端不知道数据是否会正确接收。</li><li>UDP的<code>头部开销</code>比TCP的更小，数据<code>传输速率更高</code>，<code>实时性更好</code>。</li></ol><h3 id="cookie、sessionstorage、localstorage-的区别" tabindex="-1"><a class="header-anchor" href="#cookie、sessionstorage、localstorage-的区别" aria-hidden="true">#</a> Cookie、sessionStorage、localStorage 的区别</h3><p><strong>相同点</strong>：</p><ol><li>存储在客户端</li></ol><p><strong>不同点</strong>：</p><ol><li>cookie数据大小不能超过4k；sessionStorage和localStorage的存储比cookie大得多，可以达到5M+</li><li>cookie设置的过期时间之前一直有效；localStorage永久存储，浏览器关闭后数据不丢失除非主动删除数据；sessionStorage数据在当前浏览器窗口关闭后自动删除</li><li>cookie的数据会自动的传递到服务器；sessionStorage和localStorage数据保存在本地</li></ol><h3 id="http状态码及常见状态码" tabindex="-1"><a class="header-anchor" href="#http状态码及常见状态码" aria-hidden="true">#</a> HTTP状态码及常见状态码</h3><h4 id="http状态码" tabindex="-1"><a class="header-anchor" href="#http状态码" aria-hidden="true">#</a> HTTP状态码</h4><ul><li>1xx：指示信息类，表示请求已接受，继续处理</li><li>2xx：指示成功类，表示请求已成功接受</li><li>3xx：指示重定向，表示要完成请求必须进行更近一步的操作</li><li>4xx：指示客户端错误，请求有语法错误或请求无法实现</li><li>5xx：指示服务器错误，服务器未能实现合法的请求</li></ul><h4 id="常见状态码" tabindex="-1"><a class="header-anchor" href="#常见状态码" aria-hidden="true">#</a> 常见状态码</h4><ul><li><p>200 OK：客户端请求成功</p></li><li><p>301 Moved Permanently：所请求的页面已经永久重定向至新的URL</p></li><li><p>302 Found：所请求的页面已经临时重定向至新的URL</p></li><li><p>304 Not Modified 未修改。</p></li><li><p>403 Forbidden：对请求页面的访问被禁止</p></li><li><p>404 Not Found：请求资源不存在</p></li><li><p>500 Internal Server Error：服务器发生不可预期的错误原来缓冲的文档还可以继续使用</p></li><li><p>503 Server Unavailable：请求未完成，服务器临时过载或宕机，一段时间后可恢复正常</p></li><li><p>1xx（临时响应）表示临时响应并需要请求者继续执行操作的状态码</p><ul><li>100 - 继续 请求者应当继续提出请求。服务器返回此代码表示已收到请求的第一部分，正在等待其余部分</li><li>101 - 切换协议 请求者已要求服务器切换协议，服务器已确认并准备切换</li></ul></li><li><p>2xx（成功）表示成功处理了请求的状态码</p><ul><li><code>200</code> - 成功 服务器已经成功处理了请求。通常，这表示服务器提供了请求的网页</li><li>201 - 已创建 请求成功并且服务器创建了新的资源</li><li>202 - 已接受 服务器已接受请求，但尚未处理</li><li>203 - 非授权信息 服务器已经成功处理了请求，但返回的信息可能来自另一来源</li><li>204 - 无内容 服务器成功处理了请求，但没有返回任何内容</li><li>205 - 重置内容 服务器成功处理了请求，但没有返回任何内容</li></ul></li><li><p>3xx（重定向）表示要完成请求，需要进一步操作；通常，这些状态代码用来重定向</p><ul><li>300 - 多种选择 针对请求，服务器可执行多种操作。服务器可根据请求者（user agent）选择一项操作，或提供操作列表供请求者选择</li><li><code>301</code> - 永久移动 请求的网页已永久移动到新位置。服务器返回此响应（对GET或HEAD请求的响应）时，会自动将请求者转到新位置</li><li><code>302</code> - 临时移动 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</li><li>303 - 查看其它位置 请求者应当对不同的位置使用单独的GET请求来检索响应时，服务器返回此代码</li><li><code>304</code> - 未修改 自上次请求后，请求的网页未修改过。服务器返回此响应，不会返回网页的内容</li><li>305 - 使用代理 请求者只能使用代理访问请求的网页。如果服务器返回此响应，还表示请求者应使用代理</li><li><code>307</code> - 临时性重定向 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有的位置来进行以后的请求</li></ul></li><li><p>4xx（请求错误）这些状态码表示请求可能出错，妨碍了服务器的处理</p><ul><li><code>400</code> - 错误请求 服务器不理解请求的语法</li><li><code>401</code> - 未授权 请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li><li><code>403</code> - 禁止 服务器拒绝请求</li><li><code>404</code> - 未找到 服务器找不到请求的网页</li><li>405 - 方法禁用 禁用请求中指定的方法</li><li>406 - 不接受 无法使用请求的内容特性响应请求的网页</li><li><code>407</code> - 需要代理授权 此状态码与401（未授权）类似，但指定请求者应当授权使用代理</li><li><code>408</code> - 请求超时 服务器等候请求时发生超时</li><li>410 - 已删除 如果请求的资源已永久删除，服务器就会返回此响应</li><li><code>413</code> - 请求实体过大 服务器无法处理请求，因为请求实体过大，超出了服务器的处理能力</li><li><code>414</code> - 请求的URI过长 请求的URI（通常为网址）过长，服务器无法处理</li></ul></li><li><p>5xx（服务器错误）这些状态码表示服务器在尝试处理请求时发生内部错误。这些错误可能是服务器本身的错误，而不是请求出错</p><ul><li><code>500</code> - 服务器内部错误 服务器遇到错误，无法完成请求</li><li>501 - 尚未实施 服务器不具备完成请求的功能。例如，服务器无法识别请求方法时可能会返回此代码</li><li><code>502</code> - 错误网关 服务器作为网关或代理，从上游服务器无法收到无效响应</li><li><code>503</code> - 服务器不可用 服务器目前无法使用（由于超载或者停机维护）。通常，这只是暂时状态</li><li><code>504</code> - 网关超时 服务器作为网关代理，但是没有及时从上游服务器收到请求</li><li>505 - HTTP版本不受支持 服务器不支持请求中所用的HTTP协议版本</li></ul></li></ul><h3 id="介绍下304过程" tabindex="-1"><a class="header-anchor" href="#介绍下304过程" aria-hidden="true">#</a> 介绍下304过程</h3><ol><li><p>浏览器请求资源时首先命中资源的Expires 和 Cache-Control，Expires 受限于本地时间，如果修改了本地时间，可能会造成缓存失效，可以通过Cache-control: max-age指定最大生命周期，状态仍然返回200，但不会请求数据，在浏览器中能明显看到from cache字样。</p></li><li><p>强缓存失效，进入协商缓存阶段，首先验证ETagETag可以保证每一个资源是唯一的，资源变化都会导致ETag变化。服务器根据客户端上送的If-None-Match值来判断是否命中缓存。</p></li><li><p>协商缓存Last-Modify/If-Modify-Since阶段，客户端第一次请求资源时，服务服返回的header中会加上Last-Modify，Last-modify是一个时间标识该资源的最后修改时间。再次请求该资源时，request的请求头中会包含If-Modify-Since，该值为缓存之前返回的Last-Modify。服务器收到If-Modify-Since后，根据资源的最后修改时间判断是否命中缓存。</p></li></ol><h3 id="浏览器的缓存机制-强制缓存-协商缓存" tabindex="-1"><a class="header-anchor" href="#浏览器的缓存机制-强制缓存-协商缓存" aria-hidden="true">#</a> 浏览器的缓存机制 强制缓存 &amp;&amp; 协商缓存</h3><ol><li>浏览器每次发起请求，都会<code>先在浏览器缓存中查找该请求的结果以及缓存标识</code></li><li>浏览器每次拿到返回的请求结果都会<code>将该结果和缓存标识存入浏览器缓存中</code></li></ol><p>以上两点结论就是浏览器缓存机制的关键，他确保了每个请求的缓存存入与读取，只要我们再理解浏览器缓存的使用规则，那么所有的问题就迎刃而解了。为了方便理解，这里根据是否需要向服务器重新发起HTTP请求将缓存过程分为两个部分，分别是<code>强制缓存</code>和<code>协商缓存</code>。</p><h4 id="强制缓存" tabindex="-1"><a class="header-anchor" href="#强制缓存" aria-hidden="true">#</a> 强制缓存</h4><p><code>强制缓存就是向浏览器缓存查找该请求结果，并根据该结果的缓存规则来决定是否使用该缓存结果的过程。</code>当浏览器向服务器发起请求时，服务器会将缓存规则放入HTTP响应报文的HTTP头中和请求结果一起返回给浏览器，控制强制缓存的字段分别是 <code>Expires</code> 和 <code>Cache-Control</code>，其中Cache-Control优先级比Expires高。 强制缓存的情况主要有三种：</p><ol><li>不存在该缓存结果和缓存标识，强制缓存失效，则直接向服务器发起请求（跟第一次发起请求一致）。</li><li>存在该缓存结果和缓存标识，但该结果已失效，强制缓存失效，则使用协商缓存。</li><li>存在该缓存结果和缓存标识，且该结果尚未失效，强制缓存生效，直接返回该结果</li></ol><h4 id="协商缓存" tabindex="-1"><a class="header-anchor" href="#协商缓存" aria-hidden="true">#</a> 协商缓存</h4><p><code>协商缓存就是强制缓存失效后，浏览器携带缓存标识向服务器发起请求，由服务器根据缓存标识决定是否使用缓存的过程</code>，同样，协商缓存的标识也是在响应报文的HTTP头中和请求结果一起返回给浏览器的，控制协商缓存的字段分别有：<code>Last-Modified / If-Modified-Since</code> 和 <code>Etag / If-None-Match</code>，其中<code>Etag / If-None-Match</code>的优先级比<code>Last-Modified / If-Modified-Since</code>高。 协商缓存主要有以下两种情况：</p><ol><li>协商缓存生效，返回304</li><li>协商缓存失效，返回200和请求结果结果</li></ol><h3 id="http-请求跨域问题" tabindex="-1"><a class="header-anchor" href="#http-请求跨域问题" aria-hidden="true">#</a> HTTP 请求跨域问题</h3><h4 id="跨域" tabindex="-1"><a class="header-anchor" href="#跨域" aria-hidden="true">#</a> 跨域</h4><p>指浏览器不能执行其他网站的脚本。它是由浏览器的<code>同源策略</code>造成的。跨域访问是被各大浏览器所默认禁止的</p><h4 id="同源策略" tabindex="-1"><a class="header-anchor" href="#同源策略" aria-hidden="true">#</a> 同源策略</h4><p>是浏览器对 JavaScript 实施的安全限制，只要<code>协议、域名、端口</code>有任何一个不同，都被当作是不同的域。</p><h4 id="跨域原理" tabindex="-1"><a class="header-anchor" href="#跨域原理" aria-hidden="true">#</a> 跨域原理</h4><p>通过各种方式，<code>避开浏览器的安全限制</code>。</p><h4 id="解决方案" tabindex="-1"><a class="header-anchor" href="#解决方案" aria-hidden="true">#</a> 解决方案</h4><ol><li><code>JSONP</code></li></ol><div class="language-javascript ext-js line-numbers-mode"><pre class="language-javascript"><code><span class="token comment">//动态创建 script</span>
<span class="token keyword">var</span> script <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">&#39;script&#39;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 设置回调函数</span>
<span class="token keyword">function</span> <span class="token function">getData</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//设置 script 的 src 属性，并设置请求地址</span>
script<span class="token punctuation">.</span>src <span class="token operator">=</span> <span class="token string">&#39;http://localhost:3000/?callback=getData&#39;</span><span class="token punctuation">;</span>

<span class="token comment">// 让 script 生效</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>script<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><strong>缺点：</strong> JSON 只支持 get，因为 script 标签只能使用 get 请求； JSONP 需要后端配合返回指定格式的数据。</p><ol start="2"><li><p><code>document.domain</code> 基础域名相同 子域名不同</p></li><li><p><code>window.name</code> 利用在一个浏览器窗口内，载入所有的域名都是共享一个window.name</p></li><li><p><code>CORS</code> CORS(Cross-origin resource sharing)跨域资源共享 是一种机制，是目前主流的跨域解决方案，它使用额外的 HTTP 头来告诉浏览器 让运行在一个 origin (domain) 上的Web应用被准许访问来自不同源服务器上的指定的资源。服务器设置对CORS的支持原理：服务器设置Access-Control-Allow-Origin HTTP响应头之后，浏览器将会允许跨域请求</p></li></ol><ul><li>浏览器端会自动向请求头添加origin字段，表明当前请求来源</li><li>服务器设置Access-Control-Allow-Origin、Access-Control-Allow-Methods、Access-Control-Allow-Headers等 HTTP响应头字段之后，浏览器将会允许跨域请求。</li></ul><p><strong>缺点：</strong> 会多发送一次OPTIONS请求，消耗带宽，真正的请求也会延迟</p><ol start="5"><li><code>proxy代理+Nginx</code> nginx是一款极其强大的web服务器，其优点就是轻量级、启动快、高并发。</li></ol><p>跨域问题的产生是因为浏览器的同源政策造成的，但是服务器与服务器之间的数据交换是没有这个限制。</p><p>反向代理就是采用这种方式，建立一个虚拟的代理服务器来接收 internet 上的链接请求，然后转发给内部网络上的服务器，并将从服务器上得到的结果，返回给 internet 上请求链接的客户端。现在的新项目中nginx几乎是首选，我们用node或者java开发的服务通常都需要经过nginx的反向代理。</p><ol start="6"><li><code>window.postMessage()</code> 利用h5新特性window.postMessage()</li></ol><h3 id="粘包问题分析与对策" tabindex="-1"><a class="header-anchor" href="#粘包问题分析与对策" aria-hidden="true">#</a> 粘包问题分析与对策</h3><p>TCP粘包是指发送方发送的若干包数据到接收方接收时粘成一包，从接收缓冲区看，后一包数据的头紧接着前一包数据的尾。</p><h4 id="粘包出现原因" tabindex="-1"><a class="header-anchor" href="#粘包出现原因" aria-hidden="true">#</a> 粘包出现原因</h4><p>简单得说，在流传输中出现，UDP不会出现粘包，因为它有<strong>消息边界</strong></p><p>粘包情况有两种，一种是<code>粘在一起的包都是完整的数据包</code>，另一种情况是<code>粘在一起的包有不完整的包</code>。</p><h4 id="如何避免粘包" tabindex="-1"><a class="header-anchor" href="#如何避免粘包" aria-hidden="true">#</a> 如何避免粘包</h4><ol><li>对于发送方引起的粘包现象，用户可通过编程设置来避免，<code>TCP提供了强制数据立即传送的操作指令push</code>，TCP软件收到该操作指令后，就立即将本段数据发送出去，而不必等待发送缓冲区满。但它关闭了优化算法，降低了网络发送效率，影响应用程序的性能，一般不建议使用。</li><li>对于接收方引起的粘包，则可通过优化程序设计、精简接收进程工作量、<code>提高接收进程优先级等措施</code>，使其及时接收数据，从而尽量避免出现粘包现象。但是只能减少出现粘包的可能性，但并不能完全避免粘包，当发送频率较高时，或由于网络突发可能使某个时间段数据包到达接收方较快，接收方还是有可能来不及接收，从而导致粘包。</li><li>由接收方控制，将一包数据按结构字段，人为控制分多次接收，然后合并，通过这种手段来避免粘包。<code>分包多发</code>。但应用程序的效率较低，对实时应用的场合不适合。</li><li>一种比较周全的对策是：接收方创建一预处理线程，对接收到的数据包进行预处理，将粘连的包分开。</li></ol><h3 id="客户端与服务端长连接的几种方式" tabindex="-1"><a class="header-anchor" href="#客户端与服务端长连接的几种方式" aria-hidden="true">#</a> 客户端与服务端长连接的几种方式</h3><h4 id="ajax-轮询" tabindex="-1"><a class="header-anchor" href="#ajax-轮询" aria-hidden="true">#</a> ajax 轮询</h4><h5 id="实现原理" tabindex="-1"><a class="header-anchor" href="#实现原理" aria-hidden="true">#</a> 实现原理</h5><p>ajax 轮询指客户端每间隔一段时间向服务端发起请求，保持数据的同步。</p><h5 id="优点" tabindex="-1"><a class="header-anchor" href="#优点" aria-hidden="true">#</a> 优点</h5><p>可实现基础（指间隔时间较短）的数据更新。</p><h5 id="缺点" tabindex="-1"><a class="header-anchor" href="#缺点" aria-hidden="true">#</a> 缺点</h5><p>数据更新不及时，效率低下</p><h4 id="long-poll-长轮询" tabindex="-1"><a class="header-anchor" href="#long-poll-长轮询" aria-hidden="true">#</a> long poll 长轮询</h4><h5 id="实现原理-1" tabindex="-1"><a class="header-anchor" href="#实现原理-1" aria-hidden="true">#</a> 实现原理</h5><p>long poll 指的是客户端发送请求之后，如果没有数据返回，服务端会将请求挂起放入队列（不断开连接）处理其他请求，直到有数据返回给客户端。然后客户端再次发起请求，以此轮询。在 HTTP1.0 中客户端可以设置请求头 Connection:keep-alive，服务端收到该请求头之后知道这是一个长连接，在响应报文头中也添加 Connection:keep-alive。客户端收到之后表示长连接建立完成，可以继续发送其他的请求。在 HTTP1.1 中默认使用了 Connection:keep-alive 长连接。</p><h5 id="优点-1" tabindex="-1"><a class="header-anchor" href="#优点-1" aria-hidden="true">#</a> 优点</h5><p>减少客户端的请求，降低无效的网络传输，保证每次请求都有数据返回，不会一直占用线程。</p><h5 id="缺点-1" tabindex="-1"><a class="header-anchor" href="#缺点-1" aria-hidden="true">#</a> 缺点</h5><p>无法处理高并发，消耗服务器资源严重，服务端不能主动推送</p><h4 id="iframe-长连接" tabindex="-1"><a class="header-anchor" href="#iframe-长连接" aria-hidden="true">#</a> iframe 长连接</h4><h5 id="实现原理-2" tabindex="-1"><a class="header-anchor" href="#实现原理-2" aria-hidden="true">#</a> 实现原理</h5><p>在网页上嵌入一个 iframe 标签，该标签的 src 属性指向一个长连接请求。这样服务端就可以源源不断地给客户端传输信息。保障信息实时更新。</p><h5 id="优点-2" tabindex="-1"><a class="header-anchor" href="#优点-2" aria-hidden="true">#</a> 优点</h5><p>消息及时传输。</p><h5 id="缺点-2" tabindex="-1"><a class="header-anchor" href="#缺点-2" aria-hidden="true">#</a> 缺点</h5><p>消耗服务器资源</p><h4 id="websocket" tabindex="-1"><a class="header-anchor" href="#websocket" aria-hidden="true">#</a> WebSocket</h4><h5 id="实现原理-3" tabindex="-1"><a class="header-anchor" href="#实现原理-3" aria-hidden="true">#</a> 实现原理</h5><p>Websocket 实现了客户端与服务端的双向通信，只需要连接一次，就可以相互传输数据，很适合实时通讯、数据实时更新等场景。 Websocket 协议与 HTTP 协议没有关系，它是一个建立在 TCP 协议上的全新协议，为了兼容 HTTP 握手规范，在握手阶段依然使用 HTTP 协议，握手完成之后，数据通过 TCP 通道进行传输。 Websoket 数据传输是通过 frame 形式，一个消息可以分成几个片段传输。这样大数据可以分成一些小片段进行传输，不用考虑由于数据量大导致标志位不够的情况。也可以边生成数据边传递消息，提高传输效率。</p><h5 id="优点-3" tabindex="-1"><a class="header-anchor" href="#优点-3" aria-hidden="true">#</a> 优点</h5><ol><li>双向通信。客户端和服务端双方都可以主动发起通讯。</li><li>没有同源限制。客户端可以与任意服务端通信，不存在跨域问题。</li><li>数据量轻。第一次连接时需要携带请求头，后面数据通信都不需要带请求头，减少了请求头的负荷。</li><li>传输效率高。因为只需要一次连接，所以数据传输效率高。</li></ol><h5 id="缺点-3" tabindex="-1"><a class="header-anchor" href="#缺点-3" aria-hidden="true">#</a> 缺点</h5><ol><li>需要后端代码稳定</li><li>受网络限制大</li><li>兼容性差</li><li>维护成本高</li><li>生态圈小</li></ol><h3 id="利用socket建立网络连接的步骤" tabindex="-1"><a class="header-anchor" href="#利用socket建立网络连接的步骤" aria-hidden="true">#</a> 利用Socket建立网络连接的步骤</h3><p>建立Socket连接至少需要一对套接字，其中一个运行于客户端，称为ClientSocket，另一个运行于服务器端，称为ServerSocket。</p><p>套接字之间的连接过程分为三个步骤：服务器监听，客户端请求，连接确认。</p><ol><li><code>服务器监听</code>：服务器端套接字并不定位具体的客户端套接字，而是处于等待连接的状态，实时监控网络状态，等待客户端的连接请求。</li><li><code>客户端请求</code>：指客户端的套接字提出连接请求，要连接的目标是服务器端的套接字。 为此，客户端的套接字必须首先描述它要连接的服务器的套接字，指出服务器端套接字的地址和端口号，然后就向服务器端套接字提出连接请求。</li><li><code>连接确认</code>：当服务器端套接字监听到或者说接收到客户端套接字的连接请求时，就响应客户端套接字的请求，建立一个新的线程，把服务器端套接字的描述发给客户端，一旦客户端确认了此描述，双方就正式建立连接。 而服务器端套接字继续处于监听状态，继续接收其他客户端套接字的连接请求。</li></ol><h3 id="非对称加密rsa" tabindex="-1"><a class="header-anchor" href="#非对称加密rsa" aria-hidden="true">#</a> 非对称加密RSA</h3><ol><li>对称加密算法又称现代加密算法。</li><li>非对称加密是计算机通信安全的基石，保证了加密数据不会被破解。</li><li>非对称加密算法需要两个密钥：公开密钥(publickey) 和私有密(privatekey)</li><li>公开密钥和私有密钥是一对</li></ol><p>如果用公开密钥对数据进行加密，只有用对应的私有密钥才能解密。 如果用私有密钥对数据进行加密，只有用对应的公开密钥才能解密。</p><h4 id="特点" tabindex="-1"><a class="header-anchor" href="#特点" aria-hidden="true">#</a> 特点</h4><ol><li>算法强度复杂，安全性依赖于算法与密钥</li><li>加密解密速度慢</li></ol><h4 id="与对称加密算法的对比" tabindex="-1"><a class="header-anchor" href="#与对称加密算法的对比" aria-hidden="true">#</a> 与对称加密算法的对比</h4><ol><li>对称加密只有一种密钥，并且是非公开的，如果要解密就得让对方知道密钥</li><li>非对称加密有两种密钥，其中一个是公开的</li></ol><h4 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景" aria-hidden="true">#</a> 应用场景</h4><p>由于RSA算法的加密解密速度要比对称算法速度慢很多，在实际应用中，通常采取 数据本身的加密和解密使用对称加密算法(AES)。用RSA算法加密并传输对称算法所需的密钥。</p><h3 id="http1、http2、http3" tabindex="-1"><a class="header-anchor" href="#http1、http2、http3" aria-hidden="true">#</a> HTTP1、HTTP2、HTTP3</h3><p>HTTP/2 相比于 HTTP/1.1，可以说是大幅度提高了网页的性能，只需要升级到该协议就可以减少很多之前需要做的性能优化工作，虽如此但HTTP/2并非完美的，HTTP/3 就是为了解决 HTTP/2 所存在的一些问题而被推出来的。</p><h4 id="http1-1-的缺陷" tabindex="-1"><a class="header-anchor" href="#http1-1-的缺陷" aria-hidden="true">#</a> <strong>HTTP1.1 的缺陷</strong></h4><ol><li>高延迟 — 队头阻塞(Head-Of-Line Blocking)</li></ol><p><code>队头阻塞</code>是指当顺序发送的请求序列中的一个请求因为某种原因被阻塞时，在后面排队的所有请求也一并被阻塞，会导致客户端迟迟收不到数据。</p><p>针对队头阻塞的解决办法:</p><ul><li><code>将同一页面的资源分散到不同域名下，提升连接上限</code>。</li><li><code>合并小文件减少资源数</code>，使用精灵图。</li><li><code>内联(Inlining)资源</code>是另外一种防止发送很多小图请求的技巧，将图片的原始数据嵌入在CSS文件里面的URL里，减少网络请求次数。</li><li><code>减少请求数量</code>，合并文件。</li></ul><ol start="2"><li>无状态特性 — 阻碍交互</li></ol><p><code>无状态是指协议对于连接状态没有记忆能力</code>。纯净的 HTTP 是没有 cookie 等机制的，每一个连接都是一个新的连接。</p><p><code>Header里携带的内容过大，在一定程度上增加了传输的成本</code>。且请求响应报文里有大量字段值都是重复的。</p><ol start="3"><li>明文传输 — 不安全性</li></ol><p>HTTP/1.1在传输数据时，所有<code>传输的内容都是明文</code>，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。</p><ol start="4"><li>不支持服务端推送</li></ol><h4 id="http-1-1-排队问题" tabindex="-1"><a class="header-anchor" href="#http-1-1-排队问题" aria-hidden="true">#</a> HTTP 1.1 排队问题</h4><p>HTTP 1.1多个文件共用一个TCP，这样可以减少tcp握手，这样3个文件就不用握手9次了，不过这样请求文件需要排队，请求和返回都需要排队，如果第一个文件响应慢，会阻塞后面的文件，这样就产生了队头的等待问题。</p><p>有的网站可能会有很多文件，浏览器出于对机器性能的考虑，它不可能让你无限制的发请求建连接，因为建立连接需要占用资源，浏览器不想把用户的网络资源都占用了，所以浏览器最多会建立6个tcp连接；如果有上百个文件可能都需要排队。</p><h4 id="http-2-简介" tabindex="-1"><a class="header-anchor" href="#http-2-简介" aria-hidden="true">#</a> HTTP/2 简介</h4><p>HTTP/2是现行HTTP协议（HTTP/1.x）的替代，但它不是重写。<strong>HTTP/2基于SPDY，专注于性能，最大的一个目标是在用户和网站间只用一个连接（connection）</strong> 。</p><h5 id="http-2-新特性" tabindex="-1"><a class="header-anchor" href="#http-2-新特性" aria-hidden="true">#</a> HTTP/2 新特性</h5><ol><li><p>二进制传输 <code>HTTP/2传输数据量的大幅减少,主要有两个原因:以二进制方式传输和Header 压缩</code>。我们先来介绍二进制传输,HTTP/2 采用二进制格式传输数据，而非HTTP/1.x 里纯文本形式的报文 ，二进制协议解析起来更高效。<code>HTTP/2 将请求和响应数据分割为更小的帧，并且它们采用二进制编码</code>。</p></li><li><p>Header 压缩 HTTP/2并没有使用传统的压缩算法，而是开发了专门的&quot;HPACK”算法，在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，还采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p></li><li><p>多路复用 在 HTTP/2 中引入了多路复用的技术。多路复用很好的解决了浏览器限制同一个域名下的请求数量的问题，同时也更容易实现全速传输。</p></li><li><p>Server Push HTTP2还在一定程度上改变了传统的“请求-应答”工作模式，服务器不再是完全被动地响应请求，也可以新建“流”主动向客户端发送消息。减少等待的延迟，这被称为&quot;<code>服务器推送</code>&quot;（ Server Push，也叫 Cache push）</p></li><li><p>提高安全性 出于兼容的考虑，HTTP/2延续了HTTP/1的“明文”特点，可以像以前一样使用明文传输数据，不强制使用加密通信，不过格式还是二进制，只是不需要解密。 但由于HTTPS已经是大势所趋，而且主流的浏览器Chrome、Firefox等都公开宣布只支持加密的HTTP/2，<strong>所以“事实上”的HTTP/2是加密的</strong>。也就是说，互联网上通常所能见到的HTTP/2都是使用&quot;https”协议名，跑在TLS上面。HTTP/2协议定义了两个字符串标识符：“h2&quot;表示加密的HTTP/2，“h2c”表示明文的HTTP/2。</p></li><li><p>防止队头阻塞 http1.1如果第一个文件阻塞，第二个文件也就阻塞了。 在http2.0中，把3个请求打包成一个小块发送过去，即使第一个阻塞了，后面2个也可以回来；相当于3个文件同时请求，就看谁先回来谁后回来，阻塞的可能就后回来，对带宽的利用是最高的；但没有解决TCP的队头阻塞，如果TCP发过去的一个分包发丢了，他会重新发一次；http2.0的解决了大文件的阻塞。 一个分包请求3个文件，即使第一个阻塞了，第二个也能返回</p></li></ol><h5 id="http-2-的缺点" tabindex="-1"><a class="header-anchor" href="#http-2-的缺点" aria-hidden="true">#</a> HTTP/2 的缺点</h5><p>HTTP/2的缺点主要有以下几点：</p><ol><li>TCP 以及 TCP+TLS 建立连接时延时</li><li>TCP 的队头阻塞并没有彻底解决</li><li>多路复用导致服务器压力上升也容易 Timeout</li></ol><h3 id="http1和http2的区别" tabindex="-1"><a class="header-anchor" href="#http1和http2的区别" aria-hidden="true">#</a> http1和http2的区别</h3><ol><li>http2是二进制传输</li><li>头部压缩</li><li>多路复用</li><li>服务器推送</li><li>提高安全性(https基于http2)</li><li>防止队头阻塞</li></ol><h4 id="http-3简介" tabindex="-1"><a class="header-anchor" href="#http-3简介" aria-hidden="true">#</a> HTTP/3简介</h4><p>Google 在推SPDY的时候就搞了个基于 UDP 协议的“QUIC”协议，让HTTP跑在QUIC上而不是TCP上。而“HTTP over QUIC”就是HTTP/3，真正“完美”地解决了“队头阻塞”问题。</p><p>QUIC 虽然基于 UDP，但是在原本的基础上新增了很多功能，接下来我们重点介绍几个QUIC新功能。</p><h5 id="quic新功能" tabindex="-1"><a class="header-anchor" href="#quic新功能" aria-hidden="true">#</a> QUIC新功能</h5><p>QUIC基于UDP，而UDP是“无连接”的，根本就不需要“握手”和“挥手”，所以就比TCP来得快。此外QUIC也实现了可靠传输，保证数据一定能够抵达目的地。它还引入了类似HTTP/2的“流”和“多路复用”，单个“流&quot;是有序的，可能会因为丢包而阻塞，但其他“流”不会受到影响。具体来说QUIC协议有以下特点：</p><ol><li><p>实现了类似TCP的流量控制、传输可靠性的功能 虽然UDP不提供可靠性的传输，但QUIC在UDP的基础之上增加了一层来保证数据可靠性传输。它提供了数据包重传、拥塞控制以及其他一些TCP中存在的特性。</p></li><li><p>实现了快速握手功能 由于QUIC是基于UDP的，所以QUIC可以实现使用0-RTT或者1-RTT来建立连接，这意味着QUIC可以用最快的速度来发送和接收数据，这样可以大大提升首次打开页面的速度。<strong>0RTT 建连可以说是 QUIC 相比 HTTP2 最大的性能优势</strong>。</p></li><li><p>集成了TLS加密功能</p></li><li><p>多路复用，彻底解决TCP中队头阻塞的问题 和TCP不同，QUIC实现了在同一物理连接上可以有多个独立的逻辑数据流。实现了数据流的单独传输，就解决了TCP中队头阻塞的问题。</p></li><li><p>连接迁移 TCP 是按照 4 要素（客户端 IP、端口, 服务器 IP、端口）确定一个连接的。而 QUIC 则是让客户端生成一个 Connection ID （64 位）来区别不同连接。只要 Connection ID 不变，连接就不需要重新建立，即便是客户端的网络发生变化。由于迁移客户端继续使用相同的会话密钥来加密和解密数据包，QUIC 还提供了迁移客户端的自动加密验证。</p></li></ol><h5 id="总结" tabindex="-1"><a class="header-anchor" href="#总结" aria-hidden="true">#</a> 总结</h5><ol><li>HTTP/1.1有两个主要的缺点：安全不足和性能不高。</li><li>HTTP/2完全兼容HTTP/1，是“更安全的HTTP、更快的HTTPS&quot;，二进制传输、头部压缩、多路复用、服务器推送等技术可以充分利用带宽，降低延迟，从而大幅度提高上网体验；</li><li>QUIC 基于 UDP 实现，是 HTTP/3 中的底层支撑协议，该协议基于 UDP，又取了 TCP 中的精华，实现了即快又可靠的协议。</li></ol><h3 id="xss-csrf-ddos攻击原理以及避免方式" tabindex="-1"><a class="header-anchor" href="#xss-csrf-ddos攻击原理以及避免方式" aria-hidden="true">#</a> xss，csrf，ddos攻击原理以及避免方式</h3><h4 id="xss" tabindex="-1"><a class="header-anchor" href="#xss" aria-hidden="true">#</a> XSS</h4><p><code>Cross-Site Scripting</code>，跨站脚本攻击，是一种代码注入攻击。攻击者在目标网站上注入恶意代码，当被攻击者登陆网站时就会执行这些恶意代码，这些脚本可以读取 <code>cookie，session，tokens</code>，或者其它敏感的网站信息，对用户进行钓鱼欺诈，甚至发起蠕虫攻击等。</p><h5 id="避免方式" tabindex="-1"><a class="header-anchor" href="#避免方式" aria-hidden="true">#</a> 避免方式</h5><ol><li><code>url</code>参数使用<code>encodeURIComponent</code>方法转义</li><li>尽量不是有<code>InnerHtml</code>插入<code>HTML</code>内容</li><li>使用特殊符号、标签转义符</li></ol><h4 id="csrf" tabindex="-1"><a class="header-anchor" href="#csrf" aria-hidden="true">#</a> CSRF</h4><p><code>Cross-site request forgery</code>，跨站请求伪造，攻击者诱导受害者进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用受害者在被攻击网站已经获取的注册凭证，绕过后台的用户验证，达到冒充用户对被攻击的网站执行某项操作的目的。</p><h5 id="避免方式-1" tabindex="-1"><a class="header-anchor" href="#避免方式-1" aria-hidden="true">#</a> 避免方式</h5><ol><li>添加验证码</li><li>使用token</li></ol><ul><li>服务端给用户生成一个token，加密后传递给用户</li><li>用户在提交请求时，需要携带这个token</li><li>服务端验证token是否正确</li></ul><h4 id="ddos" tabindex="-1"><a class="header-anchor" href="#ddos" aria-hidden="true">#</a> DDoS</h4><p><code>Distributed Denial of Service</code>，分布式拒绝服务，其原理就是利用大量的请求造成资源过载，导致服务不可用。</p><h5 id="避免方式-2" tabindex="-1"><a class="header-anchor" href="#避免方式-2" aria-hidden="true">#</a> 避免方式</h5><ol><li>限制单IP请求频率。</li><li>防火墙等防护设置禁止<code>ICMP</code>包等</li><li>检查特权端口的开放</li></ol><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">上次更新: </span><!----></div><div class="meta-item contributors"><span class="meta-item-label">Contributors: </span><span class="meta-item-info"><!--[--><!--[--><span class="contributor" title="email: xxz530990200@gmail.com">YukiAoi</span><!----><!--]--><!--]--></span></div></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script type="module" src="/assets/app.ebe36e73.js" defer></script>
  </body>
</html>
